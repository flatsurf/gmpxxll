{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Adding long long Support to GMP\u2019s C++ Interface \u00b6 This header only library adds long long support to GMP\u2019s C++ interface. To use it, add mpz_class.hpp to your project, e.g., by adding this repository as a submodule, and #include \"gmpxxll/mpz_class.hpp\" . That header provides a binary-compatible implementation of mpz_class . Note that what\u2019s implemented here is probably not too performant and not feature complete. Pull Requests to improve the situation are always welcome. The Reference Manual describes the interface in detail.","title":"Home"},{"location":"#adding-long-long-support-to-gmps-c-interface","text":"This header only library adds long long support to GMP\u2019s C++ interface. To use it, add mpz_class.hpp to your project, e.g., by adding this repository as a submodule, and #include \"gmpxxll/mpz_class.hpp\" . That header provides a binary-compatible implementation of mpz_class . Note that what\u2019s implemented here is probably not too performant and not feature complete. Pull Requests to improve the situation are always welcome. The Reference Manual describes the interface in detail.","title":"Adding long long Support to GMP\u2019s C++ Interface"},{"location":"doc_mpz_class_hpp/","text":"mpz_class.hpp \u2014 long long support for mpz_class . \u00b6 This file provides gmpxll::mpz_class which inherits from the official mpz_class and is binary compatible with it. This makes it possible to mix the two types quite freely. So, you might want to use gmpxxll::mpz_class where you perform (generic) conversion from/to standard integer types and use the regular mpz_class everywhere else: #include \"gmpxxll/mpz_class.hpp\" mpz_class n; gmpxxll::mpz_class m = std::limits<long long>::max; // Since gmpxxll::mpz_class is derived from mpz_class, it casts implicitly into it: n = m; // Conversely, there are explicit conversions: m = n; m = gmpxxll::mpz_class(n); Class mpz_class \u00b6 Adds long long functionality to mpz_class . This class derives from GMP\u2019s mpz_class . It is binary compatible with that class but adds some methods related to long long and unsigned long long . Note that on LP64 implementations of C++ both long and long long are 64 bits wide so this does not add anything and performance overhead should be negligible when optimizations are enabled. On LLP64 implementations, most notably Microsoft Windows, conversions actually need to take place. These conversions are probably not implemented very efficiently yet. \u00b6 Helper method that turns a (unsigned) long long value into a GMP mpz_class . Constructors \u00b6 (1) mpz_class(long long value) (2) mpz_class(unsigned long long value) Construct an mpz_class from an (unsigned) long long value. All the constructors provided by GMP\u2019s mpz_class are also available through a forwarding constructor. Type Conversion \u00b6 (1) long long get_sll() const (2) unsigned long long get_ull() const Return this integer as an (unsigned) long long value. The behaviour is undefined when the integer does not fit into an (unsigned) long long. Range Checks \u00b6 (1) bool fits_slonglong_p() const (2) bool fits_ulonglong_p() const Return whether this integers is within the range of an (unsigned) long long. Relational Operators \u00b6 (1) bool operator==(const mpz_class& lhs, const long long rhs) (2) bool operator<(const mpz_class& lhs, const long long rhs) (3) bool operator>(const mpz_class& lhs, const long long rhs) (4) bool operator==(const mpz_class& lhs, const unsigned long long rhs) (5) bool operator<(const mpz_class& lhs, const unsigned long long rhs) (6) bool operator>(const mpz_class& lhs, const unsigned long long rhs) (7) bool operator==(const long long lhs, const mpz_class& rhs) (8) bool operator!=(const mpz_class& lhs, const long long rhs) (9) bool operator!=(const long long lhs, const mpz_class& rhs) (10) bool operator<(const long long lhs, const mpz_class& rhs) (11) bool operator>(const long long lhs, const mpz_class& rhs) (12) bool operator<=(const long long lhs, const mpz_class& rhs) (13) bool operator>=(const long long lhs, const mpz_class& rhs) (14) bool operator<=(const mpz_class& lhs, const long long rhs) (15) bool operator>=(const mpz_class& lhs, const long long rhs) (16) bool operator==(const unsigned long long lhs, const mpz_class& rhs) (17) bool operator!=(const mpz_class& lhs, const unsigned long long rhs) (18) bool operator!=(const unsigned long long lhs, const mpz_class& rhs) (19) bool operator<(const unsigned long long lhs, const mpz_class& rhs) (20) bool operator>(const unsigned long long lhs, const mpz_class& rhs) (21) bool operator<=(const unsigned long long lhs, const mpz_class& rhs) (22) bool operator>=(const unsigned long long lhs, const mpz_class& rhs) (23) bool operator<=(const mpz_class& lhs, const unsigned long long rhs) (24) bool operator>=(const mpz_class& lhs, const unsigned long long rhs) All the binary operators < , <= , == , != , >= , > support long long operands. Note that binary arithmetic operators are implicitly supported because there is an implicit constructor that can cast a long long to an gmpxxll::mpz_class .","title":"gmpxxll"},{"location":"doc_mpz_class_hpp/#mpz_classhpp-long-long-support-for-mpz_class","text":"This file provides gmpxll::mpz_class which inherits from the official mpz_class and is binary compatible with it. This makes it possible to mix the two types quite freely. So, you might want to use gmpxxll::mpz_class where you perform (generic) conversion from/to standard integer types and use the regular mpz_class everywhere else: #include \"gmpxxll/mpz_class.hpp\" mpz_class n; gmpxxll::mpz_class m = std::limits<long long>::max; // Since gmpxxll::mpz_class is derived from mpz_class, it casts implicitly into it: n = m; // Conversely, there are explicit conversions: m = n; m = gmpxxll::mpz_class(n);","title":"mpz_class.hpp \u2014 long long support for mpz_class."},{"location":"doc_mpz_class_hpp/#class-mpz_class","text":"Adds long long functionality to mpz_class . This class derives from GMP\u2019s mpz_class . It is binary compatible with that class but adds some methods related to long long and unsigned long long . Note that on LP64 implementations of C++ both long and long long are 64 bits wide so this does not add anything and performance overhead should be negligible when optimizations are enabled. On LLP64 implementations, most notably Microsoft Windows, conversions actually need to take place. These conversions are probably not implemented very efficiently yet.","title":"Class mpz_class"},{"location":"doc_mpz_class_hpp/#_1","text":"Helper method that turns a (unsigned) long long value into a GMP mpz_class .","title":""},{"location":"doc_mpz_class_hpp/#constructors","text":"(1) mpz_class(long long value) (2) mpz_class(unsigned long long value) Construct an mpz_class from an (unsigned) long long value. All the constructors provided by GMP\u2019s mpz_class are also available through a forwarding constructor.","title":"Constructors"},{"location":"doc_mpz_class_hpp/#type-conversion","text":"(1) long long get_sll() const (2) unsigned long long get_ull() const Return this integer as an (unsigned) long long value. The behaviour is undefined when the integer does not fit into an (unsigned) long long.","title":"Type Conversion"},{"location":"doc_mpz_class_hpp/#range-checks","text":"(1) bool fits_slonglong_p() const (2) bool fits_ulonglong_p() const Return whether this integers is within the range of an (unsigned) long long.","title":"Range Checks"},{"location":"doc_mpz_class_hpp/#relational-operators","text":"(1) bool operator==(const mpz_class& lhs, const long long rhs) (2) bool operator<(const mpz_class& lhs, const long long rhs) (3) bool operator>(const mpz_class& lhs, const long long rhs) (4) bool operator==(const mpz_class& lhs, const unsigned long long rhs) (5) bool operator<(const mpz_class& lhs, const unsigned long long rhs) (6) bool operator>(const mpz_class& lhs, const unsigned long long rhs) (7) bool operator==(const long long lhs, const mpz_class& rhs) (8) bool operator!=(const mpz_class& lhs, const long long rhs) (9) bool operator!=(const long long lhs, const mpz_class& rhs) (10) bool operator<(const long long lhs, const mpz_class& rhs) (11) bool operator>(const long long lhs, const mpz_class& rhs) (12) bool operator<=(const long long lhs, const mpz_class& rhs) (13) bool operator>=(const long long lhs, const mpz_class& rhs) (14) bool operator<=(const mpz_class& lhs, const long long rhs) (15) bool operator>=(const mpz_class& lhs, const long long rhs) (16) bool operator==(const unsigned long long lhs, const mpz_class& rhs) (17) bool operator!=(const mpz_class& lhs, const unsigned long long rhs) (18) bool operator!=(const unsigned long long lhs, const mpz_class& rhs) (19) bool operator<(const unsigned long long lhs, const mpz_class& rhs) (20) bool operator>(const unsigned long long lhs, const mpz_class& rhs) (21) bool operator<=(const unsigned long long lhs, const mpz_class& rhs) (22) bool operator>=(const unsigned long long lhs, const mpz_class& rhs) (23) bool operator<=(const mpz_class& lhs, const unsigned long long rhs) (24) bool operator>=(const mpz_class& lhs, const unsigned long long rhs) All the binary operators < , <= , == , != , >= , > support long long operands. Note that binary arithmetic operators are implicitly supported because there is an implicit constructor that can cast a long long to an gmpxxll::mpz_class .","title":"Relational Operators"}]}